@article{10.1145/1363102.1363107,
author = {Chen, Tsong Yueh and Merkel, Robert},
title = {An Upper Bound on Software Testing Effectiveness},
year = {2008},
issue_date = {June 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {17},
number = {3},
issn = {1049-331X},
url = {https://doi.org/10.1145/1363102.1363107},
doi = {10.1145/1363102.1363107},
abstract = {Failure patterns describe typical ways in which inputs revealing program failure are distributed across the input domain—in many cases, clustered together in contiguous regions. Based on these observations several debug testing methods have been developed. We examine the upper bound of debug testing effectiveness improvements possible through making assumptions about the shape, size and orientation of failure patterns. We consider the bounds for testing strategies with respect to minimizing the F-measure, maximizing the P-measure, and maximizing the E-measure. Surprisingly, we find that the empirically measured effectiveness of some existing methods that are not based on these assumptions is close to the theoretical upper bound of these strategies. The assumptions made to obtain the upper bound, and its further implications, are also examined.},
journal = {ACM Trans. Softw. Eng. Methodol.},
month = {jun},
articleno = {16},
numpages = {27},
keywords = {failure patterns, Software testing, testing effectiveness metrics, failure-causing inputs, random testing, adaptive random testing}
}

@inproceedings{10.1145/3287324.3287471,
author = {Fraser, Gordon and Gambi, Alessio and Kreis, Marvin and Rojas, Jos\'{e} Miguel},
title = {Gamifying a Software Testing Course with Code Defenders},
year = {2019},
isbn = {9781450358903},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3287324.3287471},
doi = {10.1145/3287324.3287471},
abstract = {Software testing is an essential skill for software developers, but it is challenging to get students engaged in this activity. The Code Defenders game addresses this problem by letting students compete over code under test by either introducing faults ("attacking") or by writing tests ("defending") to reveal these faults. In this paper, we describe how we integrated Code Defenders as a semester-long activity of an undergraduate and graduate level university course on software testing. We complemented the regular course sessions with weekly Code Defenders sessions, addressing challenges such as selecting suitable code to test, managing games, and assessing performance. Our experience and our data show that the integration of Code Defenders was well-received by students and led them to practice testing thoroughly. Positive learning effects are evident as student performance improved steadily throughout the semester.},
booktitle = {Proceedings of the 50th ACM Technical Symposium on Computer Science Education},
pages = {571–577},
numpages = {7},
keywords = {software engineering education, testing game, mutation analysis, unit testing, software testing education},
location = {Minneapolis, MN, USA},
series = {SIGCSE '19}
}

@inproceedings{10.1145/1807128.1807153,
author = {Candea, George and Bucur, Stefan and Zamfir, Cristian},
title = {Automated Software Testing as a Service},
year = {2010},
isbn = {9781450300360},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1807128.1807153},
doi = {10.1145/1807128.1807153},
abstract = {This paper makes the case for TaaS--automated software testing as a cloud-based service. We present three kinds of TaaS: a "programmer's sidekick" enabling developers to thoroughly and promptly test their code with minimal upfront resource investment; a "home edition" on-demand testing service for consumers to verify the software they are about to install on their PC or mobile device; and a public "certification service," akin to Underwriters Labs, that independently assesses the reliability, safety, and security of software.TaaS automatically tests software, without human involvement from the service user's or provider's side. This is unlike today's "testing as a service" businesses, which employ humans to write tests. Our goal is to take recently proposed techniques for automated testing--even if usable only on to y programs--and make them practical by modifying them to harness the resources of compute clouds. Preliminary work suggests it is technically feasible to do so, and we find that TaaS is also compelling from a social and business point of view.},
booktitle = {Proceedings of the 1st ACM Symposium on Cloud Computing},
pages = {155–160},
numpages = {6},
keywords = {testing-as-a-service, software reliability, taas, automated testing, symbolic execution},
location = {Indianapolis, Indiana, USA},
series = {SoCC '10}
}

@inproceedings{10.1145/3059009.3059022,
author = {Smith, Rebecca and Tang, Terry and Warren, Joe and Rixner, Scott},
title = {An Automated System for Interactively Learning Software Testing},
year = {2017},
isbn = {9781450347044},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3059009.3059022},
doi = {10.1145/3059009.3059022},
abstract = {Testing is an important, time-consuming, and often difficult part of the software development process. It is therefore critical to introduce testing early in the computer science curriculum, and to provide students with frequent opportunities for practice and feedback. This paper presents an automated system to help introductory students learn how to test software. Students submit test cases to the system, which uses a large corpus of buggy programs to evaluate these test cases. In addition to gauging the quality of the test cases, the system immediately presents students with feedback in the form of buggy programs that nonetheless pass their tests. This enables students to understand why their test cases are deficient and gives them a starting point for improvement. The system has proven effective in an introductory class: students that trained using the system were later able to write better test cases -- even without any feedback -- than those who were not. Further, students reported additional benefits such as improved ability to read code written by others and to understand multiple approaches to the same problem.},
booktitle = {Proceedings of the 2017 ACM Conference on Innovation and Technology in Computer Science Education},
pages = {98–103},
numpages = {6},
keywords = {automated assessment, software testing, computer science education, interactive learning},
location = {Bologna, Italy},
series = {ITiCSE '17}
}

@inproceedings{10.5555/2821339.2821341,
author = {Feldt, Robert and Poulding, Simon},
title = {Broadening the Search in Search-Based Software Testing: It Need Not Be Evolutionary},
year = {2015},
publisher = {IEEE Press},
abstract = {Search-based software testing (SBST) can potentially help software practitioners create better test suites using less time and resources by employing powerful methods for search and optimization. However, research on SBST has typically focused on only a few search approaches and basic techniques. A majority of publications in recent years use some form of evolutionary search, typically a genetic algorithm, or, alternatively, some other optimization algorithm inspired from nature. This paper argues that SBST researchers and practitioners should not restrict themselves to a limited choice of search algorithms or approaches to optimization. To support our argument we empirically investigate three alternatives and compare them to the de facto SBST standards in regards to performance, resource efficiency and robustness on different test data generation problems: classic algorithms from the optimization literature, bayesian optimization with gaussian processes from machine learning, and nested monte carlo search from game playing / reinforcement learning. In all cases we show comparable and sometimes better performance than the current state-of-the-SBST-art. We conclude that SBST researchers should consider a more general set of solution approaches, more consider combinations and hybrid solutions and look to other areas for how to develop the field.},
booktitle = {Proceedings of the Eighth International Workshop on Search-Based Software Testing},
pages = {1–7},
numpages = {7},
location = {Florence, Italy},
series = {SBST '15}
}

@proceedings{10.5555/3340872,
title = {SBST '19: Proceedings of the 12th International Workshop on Search-Based Software Testing},
year = {2019},
publisher = {IEEE Press},
abstract = {Welcome to the 12th edition of the International Workshop on Search-Based Software Testing (SBST). There is a growing realization that optimization techniques can be applied to many aspects of the software development process: a research area known as Search-Based Software Engineering (SBSE). Search-Based Software Testing - one of the largest research areas within SBSE - is the process of using search-based optimization algorithms to specifically address problems in software testing. SBST has been applied to a wide variety of testing goals including structural, functional, non-functional and state-based properties. Many approaches to testing and a wide diverse range of development domains have been addressed, including exceptions, interactions, integration, mutation, regression, and web applications.Work in SBST has developed to the point at which it is now ripe for combination with other areas of software engineering. The common "lingua franca" that makes these combinations possible is the definition of the fitness function that guides a search algorithm. A fitness function is merely a form of a metric, and metrics exist across the entire software engineering spectrum. Therefore, the central objective of this workshop is to bring together researchers and industrial practitioners from SBST and the wider software engineering community to share experience and provide directions for future research, and to encourage the use of search techniques to combine aspects of testing with other aspects of the software engineering lifecycle.},
location = {Montreal, Quebec, Canada}
}

@article{10.1145/3395029,
author = {Zhang, Xihui and Stafford, Thomas F. and Hu, Tao and Dai, Hua},
title = {Measuring Task Conflict and Person Conflict in Software Testing},
year = {2020},
issue_date = {October 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {29},
number = {4},
issn = {1049-331X},
url = {https://doi.org/10.1145/3395029},
doi = {10.1145/3395029},
abstract = {Task-related conflict and person-related conflict in software testing are inevitable and can impact the effectiveness and efficiency of the software development process. The dimensionality of conflict in software testing is reasonably well understood, although in past research both types of conflict have frequently been modeled as reflective constructs that can obstruct the effectiveness of their use as organizational assessment and training tools. One contribution of this study is an empirical model of conflict sources in software engineering; such sources of conflict threaten to derail efficient software development outcomes in firms. A second contribution of this research is the development of a formative measurement model for purposes of development of assessing task conflict and person conflict in software teams. These validated measures can be utilized as training and development instruments for on-the-job remediation of development team conflict. As is indicated in the organizational behavior and software engineering literature, deploying valid measures of workplace stressors such as conflict can lead to the managerial application of effective strategies and tactics to improve workplace morale and satisfaction, to the great benefit of productivity and retention.},
journal = {ACM Trans. Softw. Eng. Methodol.},
month = {jul},
articleno = {25},
numpages = {19},
keywords = {task conflict, software development, person conflict, formative measurement, Software testing}
}

@inproceedings{10.1145/1980422.1980445,
author = {Rathore, Abhishek and Bohara, Atul and Prashil, R. Gupta and Prashanth, T. S. Lakshmi and Srivastava, Praveen Ranjan},
title = {Application of Genetic Algorithm and Tabu Search in Software Testing},
year = {2011},
isbn = {9781450307505},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1980422.1980445},
doi = {10.1145/1980422.1980445},
abstract = {This paper presents a technique for automatic test-data generation in software testing. The proposed approach is based on genetic and tabu search algorithms. It combines the strength of two metaheuristic techniques and produces efficient results. The conventional approach for test-data generation using genetic algorithm is modified by applying a tabu search heuristic in mutation step. It also incorporates backtracking process to move search away from local optima. The experimental results show that the algorithm is effective in providing test data and its performance is better than simple genetic algorithm.},
booktitle = {Proceedings of the Fourth Annual ACM Bangalore Conference},
articleno = {23},
numpages = {4},
keywords = {software testing, test-data generation, tabu search, genetic algorithm, control dependence graph, structural testing},
location = {Bangalore, India},
series = {COMPUTE '11}
}

@inproceedings{10.1145/1500412.1500462,
author = {Holthouse, M. A. and Lybrook, C. W.},
title = {Improving Software Testing in Large Data Processing Organizations},
year = {1981},
isbn = {9781450379212},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1500412.1500462},
doi = {10.1145/1500412.1500462},
abstract = {Software testing is one of the most critical tasks performed by a large data processing organization. Testing is important in the development of new systems, but it may have an even greater impact on the maintenance of the production systems. In spite of this, testing is rarely approached in the same disciplined manner as are other software production activities. Perhaps as a result of this situation, an organization can often achieve significant improvements in both software testing effectiveness and efficiency through a relatively low-cost investment in testing methodologies, tools, and techniques. This paper describes just such an investment undertaken by the Information Services Group of Chemical Bank. Particular emphasis is placed on how this program for testing improvement was implemented, in addition to what it consists of. Finally, results of the program to date are presented and analyzed.},
booktitle = {Proceedings of the May 4-7, 1981, National Computer Conference},
pages = {353–359},
numpages = {7},
location = {Chicago, Illinois},
series = {AFIPS '81}
}

@proceedings{10.1145/3194718,
title = {SBST '18: Proceedings of the 11th International Workshop on Search-Based Software Testing},
year = {2018},
isbn = {9781450357418},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
abstract = {There is a growing realization that optimization can be applied to many aspects of the software development process: a research area known as Search Based Software Engineering (SBSE). Search Based Software Testing - one of the largest research areas within SBSE - is the process of using search-based optimization algorithms to specifically address problems in software testing. SBST has been applied to a wide variety of testing goals including structural, functional, non-functional and state- based properties. Many approaches to testing and a wide diverse range of development domains have been addressed, including exceptions, interactions, integration, mutation, regression, and web applications.Work in SBST has developed to the point at which it is now ripe for combination with other areas of software engineering. The common "lingua franca" that makes these combinations possible is the definition of the fitness function that guides a search algorithm. A fitness function is merely a form of a metric, and metrics exist across the entire software engineering spectrum. Therefore, the central objective of this workshop is to bring together researchers and industrial practitioners from SBST and the wider software engineering community to share experience and provide directions for future research, and to encourage the use of search techniques to combine aspects of testing with other aspects of the software engineering lifecycle.SBST is a two-day workshop aimed at bringing testing researchers together with the broader software engineering community to discuss state-of-the-art work and set new research directions.},
location = {Gothenburg, Sweden}
}

@proceedings{10.5555/2821339,
title = {SBST '15: Proceedings of the Eighth International Workshop on Search-Based Software Testing},
year = {2015},
publisher = {IEEE Press},
abstract = {There is a growing realization that optimization can be applied to many aspects of the software development process - a research area known as Search- Based Software Engineering (SBSE). Search- Based Software Testing - one of the largest research areas within SBSE - is the process of using searchbased optimization algorithms to specifically address problems in software testing. SBST has been applied to a wide variety of testing goals including structural, functional, non-functional and state-based properties. Many approaches to testing and a wide diverse range of development domains have been addressed, including exceptions, interactions, integration, mutation, regression, and web applications.Work in SBST has developed to the point at which it is now ripe for combination with other areas of software engineering. The common "lingua franca" that makes these combinations possible is the definition of the fitness function that guides a search algorithm. A fitness function is merely a form of metric, and metrics exist across the entire software engineering spectrum. Therefore, the central objective of this workshop is to bring together researchers and industrial practitioners from SBST and the wider software engineering community to share experience and provide directions for future research, and to encourage the use of search techniques to combine aspects of testing with other aspects of the software engineering lifecycle.},
location = {Florence, Italy}
}

@proceedings{10.1145/2897010,
title = {SBST '16: Proceedings of the 9th International Workshop on Search-Based Software Testing},
year = {2016},
isbn = {9781450341660},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
abstract = {There is a growing realization that optimization can be applied to many aspects of the software development process - a research area known as Search Based Software Engineering (SBSE). Search Based Software Testing - one of the largest research areas within SBSE - is the process of using search-based optimization algorithms to specifically address problems in software testing. SBST has been applied to a wide variety of testing goals including structural, functional, non-functional and statebased properties. Many approaches to testing and a wide diverse range of development domains have been addressed, including exceptions, interactions, integration, mutation, regression, and web applications.Work in SBST has developed to the point at which it is now ripe for combination with other areas of software engineering. The common "lingua franca" that makes these combinations possible is the definition of the fitness function that guides a search algorithm. A fitness function is merely a form of a metric, and metrics exist across the entire software engineering spectrum. Therefore, the central objective of this workshop is to bring together researchers and industrial practitioners from SBST and the wider software engineering community to share experience and provide directions for future research, and to encourage the use of search techniques to combine aspects of testing with other aspects of the software engineering lifecycle.},
location = {Austin, Texas}
}

@inproceedings{10.1145/3185089.3185125,
author = {Yu, Jiujiu},
title = {Review of Panorama and Key Technical Prospect on Software Testing},
year = {2018},
isbn = {9781450354141},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3185089.3185125},
doi = {10.1145/3185089.3185125},
abstract = {From the perspective of definition, faction, method, layer, mode, technique, process and management for total eight aspects to review of the contexts on panorama of software testing. And an initial expectation on key technologies of software testing is also given under the background on mobile internet, the internet of things, big data, and cloud testing on future research.},
booktitle = {Proceedings of the 2018 7th International Conference on Software and Computer Applications},
pages = {61–65},
numpages = {5},
keywords = {the internet of things, web testing, panorama, mobile internet, big data, cloud testing, Software testing},
location = {Kuantan, Malaysia},
series = {ICSCA 2018}
}

@inproceedings{10.5555/800253.807741,
author = {Jessop, W. H. and Kane, J. R. and Roy, S. and Scanlon, J. M.},
title = {ATLAS-An Automated Software Testing System},
year = {1976},
publisher = {IEEE Computer Society Press},
address = {Washington, DC, USA},
abstract = {The Automated Testing and Load Analysis System (ATLAS) formalizes a concept of model-referenced testing for large software systems. A directed graph model of the software under test, describing the sequential stimulus-response behavior of the software system, forms the basis of the approach. The objective of ATLAS is to certify the software under test against the model. This objective is met by components of ATLAS that automatically identify, generate, apply, and verify the set of tests required to establish that the software has correctly realized the model. The system has been successfully employed in testing over 40,000 instructions of Bell Laboratories large No. 4 ESS software package. Usage data and experience from this application and a critique of the approach are given.},
booktitle = {Proceedings of the 2nd International Conference on Software Engineering},
pages = {629–635},
numpages = {7},
keywords = {Software modeling, Program testing, Automated test generation},
location = {San Francisco, California, USA},
series = {ICSE '76}
}

@article{10.1145/1838687.1838692,
author = {Chan, Wing Kwong and Budnik, Christof J. and Kapfhammer, Gregory M.},
title = {Software Testing Research in Practice: Report on the 5th International Workshop on the Automation of Software Test},
year = {2010},
issue_date = {September 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {35},
number = {5},
issn = {0163-5948},
url = {https://doi.org/10.1145/1838687.1838692},
doi = {10.1145/1838687.1838692},
abstract = {The 5th Workshop on the Automation of Software Test co-located with ICSE 2010 provides a publication forum that bridges the gap between the theory and practice of automated testing. The workshop featured a twoday high quality programs with a multi-session charette on integration testing. Researchers shared with us their insights on software testing through 15 regular papers and 6 case-study papers were presented in six sessions at the workshop. This report summarizes the organization of the workshop as well as the sessions and papers presented, the results of the charette session, attendee feedback, and lessons learned.},
journal = {SIGSOFT Softw. Eng. Notes},
month = {oct},
pages = {25–26},
numpages = {2},
keywords = {automation, testing, software verification}
}

@inproceedings{10.5555/2663608.2663615,
author = {Muccini, Henry and Di Francesco, Antonio and Esposito, Patrizio},
title = {Software Testing of Mobile Applications: Challenges and Future Research Directions},
year = {2012},
isbn = {9781467318228},
publisher = {IEEE Press},
abstract = {While mobile applications are becoming so extraordinarily adopted, it is still unclear if they deserve any specific testing approach for their verification and validation. This paper wants to investigate new research directions on mobile applications testing automation, by answering three research questions: (RQ1) are mobile applications (so) different from traditional ones, so to require different and specialized new testing techniques?, (RQ2) what are the new challenges and research directions on testing mobile applications?, and (RQ3) which is the role automation may play in testing mobile applications?. We answer those questions by analyzing the current state of the art in mobile applications development and testing, and by proposing our view on the topic.},
booktitle = {Proceedings of the 7th International Workshop on Automation of Software Test},
pages = {29–35},
numpages = {7},
location = {Zurich, Switzerland},
series = {AST '12}
}

@inproceedings{10.1145/3172871.3172881,
author = {Tiwari, Saurabh and Saini, Veena and Singh, Paramvir and Sureka, Ashish},
title = {A Case Study on the Application of Case-Based Learning in Software Testing},
year = {2018},
isbn = {9781450363983},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3172871.3172881},
doi = {10.1145/3172871.3172881},
abstract = {Software testing is a popular mean of examining the adequacy of a developed product. However, in academic institutions more emphasis is given to software development than ensuring its quality. In order to address the gaps between existing university-level software testing education and the training standards used in industry, we experiment with employing a popular teaching method Case-Based Learning (CBL) for the first time to facilitate the training of selected software testing concepts at tertiary-level. The CBL exercise is conducted for undergraduate students of DAIICT, Gandhinagar (India) to cultivate the decision making skills in a self-learning environment. After the CBL execution we collect students' responses through a short survey and perform an empirical analysis on the survey results. The outcome of this CBL practice is positive as a majority of students are able to achieve the five stated objectives of CBL. We examine that there is a statistically significant difference between students' responses based on gender diversity. We also investigate the difference in students' feedback to the two different CBL cases that we use for practicing some aspects of software testing. Moreover, we draw useful inferences from the opinions of TAs (Teaching Assistants) about the CBL sessions.},
booktitle = {Proceedings of the 11th Innovations in Software Engineering Conference},
articleno = {11},
numpages = {5},
keywords = {teaching methodology, case-based learning, software testing, Software engineering education},
location = {Hyderabad, India},
series = {ISEC '18}
}

@inproceedings{10.1145/3274856.3274865,
author = {Yamamoto, Masato and Pyshkin, Evgeny and Mozgovoy, Maxim},
title = {Reducing False Positives in Automated OpenCV-Based Non-Native GUI Software Testing},
year = {2018},
isbn = {9781450365161},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3274856.3274865},
doi = {10.1145/3274856.3274865},
abstract = {This paper is aimed at improving mobile game non-native GUI testing. We follow an approach to use OpenCV image recognition algorithms for detecting and accessing the hand-drawn GUI elements on the screen, in order to interact with them from within automated test scripts. In the previous work, we experienced the problem that some tests fail not due to the defects of the tested software itself, but because of the false positive results of template matching. It means that the high scores are sometimes elicited for the best match, though the requested GUI element is actually not present on the screen. In this contribution we investigate the possibilities of image filtering in order to reduce the number of such false positive cases. We describe our experiments with two algorithms supported by OpenCV library, a selection of GUI elements and mobile game scenes, and a number of image filtering methods. We demonstrate that using Canny edge detection filters can significantly improve the accuracy of recognizing false positive cases without affecting the true positive situations. Our conclusions can be helpful for improving hand-drawn GUI based mobile software testing reliability.},
booktitle = {Proceedings of the 3rd International Conference on Applications in Information Technology},
pages = {41–45},
numpages = {5},
keywords = {Software testing, false positive, non-native GUI, image recognition},
location = {Aizu-Wakamatsu, Japan},
series = {ICAIT'2018}
}

@inproceedings{10.1145/2486046.2486052,
author = {Nguyen, Vu and Pham, Vu and Lam, Vu},
title = {QEstimation: A Process for Estimating Size and Effort of Software Testing},
year = {2013},
isbn = {9781450320627},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2486046.2486052},
doi = {10.1145/2486046.2486052},
abstract = { Software testing is an essential activity of the software development lifecycle. To ensure quality, applicability, and usefulness of a product, development teams must spend considerable time and resources testing, which makes the estimation of the software testing effort, a critical activity. This paper describes a simple process, which we name qEstimation, to estimate the size and effort of the software testing activities. The process incorporates a proposed approach to measuring the size of the test case based on its checkpoints, preconditions and test data, as well as the type of testing. To investigate the practicality of the process, we apply it to estimate the size and effort of two outsourcing testing projects at a software company. In these projects, the estimates produced by the process are more accurate than those estimated by individual testers using their pure experience. This result indicates that our approach can be useful to estimating similar testing projects in practice. },
booktitle = {Proceedings of the 2013 International Conference on Software and System Process},
pages = {20–28},
numpages = {9},
keywords = {qestimation, test case point, quality assurance, software testing, software test estimation, test management},
location = {San Francisco, CA, USA},
series = {ICSSP 2013}
}

@inproceedings{10.1145/3321707.3321720,
author = {Zhu, Ziming and Jiao, Li},
title = {Improving Search-Based Software Testing by Constraint-Based Genetic Operators},
year = {2019},
isbn = {9781450361118},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3321707.3321720},
doi = {10.1145/3321707.3321720},
abstract = {Search-based software testing (SBST) has achieved great attention as an effective technique to automate test data generation. The testing problem is converted into a search problem, and a meta-heuristic algorithm is used to search for the test data in SBST. Genetic Algorithm (GA) is the most popular meta-heuristic algorithm used in SBST and the genetic operators are the key parts in GA. Much work has been done to improve SBST while little research has concentrated on the genetic operators. Due to the blindness and randomness of classic genetic operators, SBST is ineffective in many cases. In this paper, we focus on improving the genetic operators by constraint-based software testing. Compared with classic genetic operators, our improved genetic operators are more purposeful. For the selection operator, we use symbolic execution technique to help us select the test cases which have more useful heuristic information. Then, the constraint-based crossover operator recombines the test cases which have more probability to create better offspring individuals. Finally, the constraint-based mutation operator is used to improve the test cases in order to satisfy some specific constraints. We applied our constraint-based genetic operators in several benchmarks and the experiments reveal the promising results of our proposal.},
booktitle = {Proceedings of the Genetic and Evolutionary Computation Conference},
pages = {1435–1442},
numpages = {8},
keywords = {search-based software testing, constraint-based testing, genetic operators},
location = {Prague, Czech Republic},
series = {GECCO '19}
}

