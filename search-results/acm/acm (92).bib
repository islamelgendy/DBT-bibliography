@article{10.1145/1022494.1022575,
author = {Tracz, Will},
title = {Frontmatter (TOC, Letters, Frank David Anger, ACM Fellow Profile, ICSE 2005, Praise and Criticism, Some Thoughts on Software Reliability, Latest DoD Effort to Achieve Quality in Software, Software Engineering Education)},
year = {2004},
issue_date = {September 2004},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {29},
number = {5},
issn = {0163-5948},
url = {https://doi.org/10.1145/1022494.1022575},
doi = {10.1145/1022494.1022575},
journal = {SIGSOFT Softw. Eng. Notes},
month = {sep},
pages = {0},
numpages = {14}
}

@article{10.1145/219663.219693,
author = {Author Index},
title = {Communications of the ACM 1995 Author Index},
year = {1995},
issue_date = {Dec. 1995},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {38},
number = {12},
issn = {0001-0782},
url = {https://doi.org/10.1145/219663.219693},
doi = {10.1145/219663.219693},
journal = {Commun. ACM},
month = {dec},
pages = {91–99},
numpages = {9}
}

@inproceedings{10.1145/126551.126613,
author = {Heide, H. and Lindheim, A. and Selfridge, W. P.},
title = {SPTP: The Software Process Training Program},
year = {1991},
isbn = {0897914457},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/126551.126613},
doi = {10.1145/126551.126613},
booktitle = {Proceedings of the Conference on TRI-Ada '91: Today's Accomplishments; Tomorrow's Expectations},
pages = {485–496},
numpages = {12},
location = {San Jose, California, USA},
series = {TRI-Ada '91}
}

@inproceedings{10.1145/1878537.1878610,
author = {Garcia, Johnny},
title = {Methodology Supporting Architecture Validations (MAVS)},
year = {2010},
isbn = {9781450300698},
publisher = {Society for Computer Simulation International},
address = {San Diego, CA, USA},
url = {https://doi.org/10.1145/1878537.1878610},
doi = {10.1145/1878537.1878610},
abstract = {Defense Information Technology Architecture is a complex business. Furthermore, the multitude and magnitude of the tasks and operations that are executed simultaneously on a battlefield to conduct a single mission are simply staggering. From the performance of a single system, to the actions of integrated systems, to the decisions made by military commanders engaged in an Area of Operations, all the disparate pieces and parts of equipment and personnel on a battlefield must be combined and synchronized to achieve maximum effect. As the beginning of the 21st century unfolds, it is clear that the enemy and the way we wage war is changing. Staying ahead of this change will be a great challenge and will require a complete understanding of the threats that seek to harm us as well as the regions and conditions where they exist. It has become increasingly necessary to research, design and test new systems and concepts on shorter timelines while simultaneously fighting new threats. The use of models and simulations to assist with this task is increasing but, in order for models and simulations to be valid, they must be able to describe, depict and replicate real, simulated and conceptual military operations so that the resulting data can be used to study new solutions to counter future threats. How do we study the planning and execution of military operations, tracking hundreds of different types of equipment and personnel, performing myriad tasks that synchronously are able to achieve success in combat? Is it possible to replicate the chaos of a battlefield and capture the rigor of military operations in order to accurately predict the performance of new concepts and capabilities so that they can be quickly integrated into current and future force structures? This research addresses these questions.},
booktitle = {Proceedings of the 2010 Spring Simulation Multiconference},
articleno = {70},
numpages = {9},
keywords = {modeling and simulation, DEVS, DoDAF, validation, executable architectures},
location = {Orlando, Florida},
series = {SpringSim '10}
}

@inproceedings{10.1145/3412841.3442029,
author = {Ferreira, Fabio and Silva, Luciana Lourdes and Valente, Marco Tulio},
title = {Software Engineering Meets Deep Learning: A Mapping Study},
year = {2021},
isbn = {9781450381048},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3412841.3442029},
doi = {10.1145/3412841.3442029},
abstract = {Deep Learning (DL) is being used nowadays in many traditional Software Engineering (SE) problems and tasks. However, since the renaissance of DL techniques is still very recent, we lack works that summarize and condense the most recent and relevant research conducted at the intersection of DL and SE. Therefore, in this paper, we describe the first results of a mapping study covering 81 papers about DL &amp; SE. Our results confirm that DL is gaining momentum among SE researchers over the years and that the top-3 research problems tackled by the analyzed papers are documentation, defect prediction, and testing.},
booktitle = {Proceedings of the 36th Annual ACM Symposium on Applied Computing},
pages = {1542–1549},
numpages = {8},
keywords = {software engineering, deep learning},
location = {Virtual Event, Republic of Korea},
series = {SAC '21}
}

@inproceedings{10.1145/3368308.3415358,
author = {Philips, James and Fenwick, Nathanael and Davis, Storm and Tabrizi, Nasseh},
title = {Improving Student Success through an Articulation Program in Software Engineering},
year = {2020},
isbn = {9781450370455},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3368308.3415358},
doi = {10.1145/3368308.3415358},
abstract = {The swift advancement of computerization has resulted in an increased need for individuals skilled in a variety of highly technical fields. This demand is currently inadequately met by the United States? domestic workforce and rural areas are underserved by technological resources and opportunities. Due to political and legislative volatility, fixing this workforce shortage is not feasible. Instead, the long-term solution is the cultivation of domestic workforce with high technical expertise. Therefore, we propose a software engineering curriculum that follows the 2 + 2 educational model to meet the needs of community college students in North Carolina as a model for similar initiatives on a regional and national scale. In this paper, we discuss the current status of computer science and software engineering education in North Carolina community colleges, including the current degree programs and relevant curriculum content. Finally, we discuss our proposed curriculum for a 2 + 2 articulation program in software engineering.},
booktitle = {Proceedings of the 21st Annual Conference on Information Technology Education},
pages = {378–383},
numpages = {6},
keywords = {community colleges, software engineering education, 2+2 program},
location = {Virtual Event, USA},
series = {SIGITE '20}
}

@article{10.1145/3432924,
author = {Choi, Yoonseo and Monserrat, Toni-Jan Keith Palma and Park, Jeongeon and Shin, Hyungyu and Lee, Nyoungwoo and Kim, Juho},
title = {ProtoChat: Supporting the Conversation Design Process with Crowd Feedback},
year = {2021},
issue_date = {December 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {CSCW3},
url = {https://doi.org/10.1145/3432924},
doi = {10.1145/3432924},
abstract = {Similar to a design process for designing graphical user interfaces, conversation designers often apply an iterative design process by defining a conversation flow, testing with users, reviewing user data, and improving the design. While it is possible to iterate on conversation design with existing chatbot prototyping tools, there still remain challenges in recruiting participants on-demand and collecting structured feedback on specific conversational components. These limitations hinder designers from running rapid iterations and making informed design decisions. We posit that involving a crowd in the conversation design process can address these challenges, and introduce ProtoChat, a crowd-powered chatbot design tool built to support the iterative process of conversation design. ProtoChat makes it easy to recruit crowd workers to test the current conversation within the design tool. ProtoChat's crowd-testing tool allows crowd workers to provide concrete and practical feedback and suggest improvements on specific parts of the conversation. With the data collected from crowd-testing, ProtoChat provides multiple types of visualizations to help designers analyze and revise their design. Through a three-day study with eight designers, we found that ProtoChat enabled an iterative design process for designing a chatbot. Designers improved their design by not only modifying the conversation design itself, but also adjusting the persona and getting UI design implications beyond the conversation design itself. The crowd responses were helpful for designers to explore user needs, contexts, and diverse response formats. With ProtoChat, designers can successfully collect concrete evidence from the crowd and make decisions to iteratively improve their conversation design.},
journal = {Proc. ACM Hum.-Comput. Interact.},
month = {jan},
articleno = {225},
numpages = {27},
keywords = {design process, crowd testing, crowdsourcing, conversational user interface, design iteration, chatbot design, crowd feedback, conversation design}
}

@inproceedings{10.1145/581339.581393,
author = {Chandra, Satish and Godefroid, Patrice and Palm, Christopher},
title = {Software Model Checking in Practice: An Industrial Case Study},
year = {2002},
isbn = {158113472X},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/581339.581393},
doi = {10.1145/581339.581393},
abstract = {We present an application of software model checking to the analysis of a large industrial software product: Lucent Technologies' CDMA call-processing library. This software is deployed on thousands of base stations in wireless networks world-wide, where it sets up and manages millions of calls to and from mobile devices everyday. Our analysis of this software was carried out using VeriSoft, a tool developed at Bell Laboratories that implements model-checking algorithms for systematically testing concurrent reactive software.VeriSoft has now been used for over a year for analyzing several releases and versions of the CDMA call-processing software. Although we started this work with a fairly robust version of the software, the application of model checking exposed several problems that had escaped traditional testing. Model checking also helped developers maintain a high degree of confidence in the library as it evolved through its many releases and versions.To our knowledge, software model checking has rarely been applied to software systems of this scale. In this paper, we describe our experience in applying this technology in an industrial environment.},
booktitle = {Proceedings of the 24th International Conference on Software Engineering},
pages = {431–441},
numpages = {11},
location = {Orlando, Florida},
series = {ICSE '02}
}

@inproceedings{10.1145/1837274.1837333,
author = {Lisherness, Peter and Cheng, Kwang-Ting (Tim)},
title = {SCEMIT: A Systemc Error and Mutation Injection Tool},
year = {2010},
isbn = {9781450300025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1837274.1837333},
doi = {10.1145/1837274.1837333},
abstract = {As high-level models in C and SystemC are increasingly used for verification and even design (through high-level synthesis) of electronic systems, there is a growing need for compatible error injection tools to facilitate further development of coverage metrics and automated diagnosis. This paper introduces SCEMIT, a tool for the automated injection of errors into C/C++/SystemC models. A selection of 'mutation' style errors are supported, and injection is performed though a plugin interface in the GCC compiler, which minimizes the impact of SCEMIT on existing simulation flows. Experimental injected error detection results are presented for the set of OSCI SystemC Example Models as well as the CHStone C High-Level-Synthesis benchmark set. Aside from demonstrating compatibility with these models, the results show the value of high-level error injection as a coverage measure compared to conventional code coverage measures.},
booktitle = {Proceedings of the 47th Design Automation Conference},
pages = {228–233},
numpages = {6},
keywords = {SystemC, coverage, high-level synthesis, mutation},
location = {Anaheim, California},
series = {DAC '10}
}

@inproceedings{10.1145/1868328.1868330,
author = {Harman, Mark},
title = {The Relationship between Search Based Software Engineering and Predictive Modeling},
year = {2010},
isbn = {9781450304047},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1868328.1868330},
doi = {10.1145/1868328.1868330},
abstract = {Search Based Software Engineering (SBSE) is an approach to software engineering in which search based optimization algorithms are used to identify optimal or near optimal solutions and to yield insight. SBSE techniques can cater for multiple, possibly competing objectives and/ or constraints and applications where the potential solution space is large and complex. This paper will provide a brief overview of SBSE, explaining some of the ways in which it has already been applied to construction of predictive models. There is a mutually beneficial relationship between predictive models and SBSE. The paper sets out eleven open problem areas for Search Based Predictive Modeling and describes how predictive models also have role to play in improving SBSE.},
booktitle = {Proceedings of the 6th International Conference on Predictive Models in Software Engineering},
articleno = {1},
numpages = {13},
location = {Timi\c{s}oara, Romania},
series = {PROMISE '10}
}

@article{10.1145/2770929,
author = {Gilbert, Juan E. and Jackson, Jerlando F. L. and Dillon, Edward C. and Charleston, LaVar J.},
title = {African Americans in the U.S. Computing Sciences Workforce},
year = {2015},
issue_date = {July 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {58},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/2770929},
doi = {10.1145/2770929},
abstract = {An exploration of the education-to-work pipeline.},
journal = {Commun. ACM},
month = {jun},
pages = {35–38},
numpages = {4}
}

@article{10.1145/3316415,
author = {Wenzl, Matthias and Merzdovnik, Georg and Ullrich, Johanna and Weippl, Edgar},
title = {From Hack to Elaborate Technique—A Survey on Binary Rewriting},
year = {2019},
issue_date = {May 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {3},
issn = {0360-0300},
url = {https://doi.org/10.1145/3316415},
doi = {10.1145/3316415},
abstract = {Binary rewriting is changing the semantics of a program without having the source code at hand. It is used for diverse purposes, such as emulation (e.g., QEMU), optimization (e.g., DynInst), observation (e.g., Valgrind), and hardening (e.g., Control flow integrity enforcement). This survey gives detailed insight into the development and state-of-the-art in binary rewriting by reviewing 67 publications from 1966 to 2018. Starting from these publications, we provide an in-depth investigation of the challenges and respective solutions to accomplish binary rewriting. Based on our findings, we establish a thorough categorization of binary rewriting approaches with respect to their use-case, applied analysis technique, code-transformation method, and code generation techniques. We contribute a comprehensive mapping between binary rewriting tools, applied techniques, and their domain of application. Our findings emphasize that although much work has been done over the past decades, most of the effort was put into improvements aiming at rewriting general purpose applications but ignoring other challenges like altering throughput-oriented programs or software with real-time requirements, which are often used in the emerging field of the Internet of Things. To the best of our knowledge, our survey is the first comprehensive overview on the complete binary rewriting process.},
journal = {ACM Comput. Surv.},
month = {jun},
articleno = {49},
numpages = {37},
keywords = {reassembly, dynamic rewriting, full-translation, static rewriting, Binary rewriting, binary hardening, minimal-invasive}
}

@article{10.1145/966221.966669,
author = {ACM SIGSOFT Software Engineering Notes staff},
title = {Back Matter},
year = {2003},
issue_date = {November 2003},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {28},
number = {6},
issn = {0163-5948},
url = {https://doi.org/10.1145/966221.966669},
doi = {10.1145/966221.966669},
journal = {SIGSOFT Softw. Eng. Notes},
month = {nov},
pages = {33–36},
numpages = {4}
}

@inproceedings{10.1109/ICSE.2019.00097,
author = {Wang, Junjie and Yang, Ye and Krishna, Rahul and Menzies, Tim and Wang, Qing},
title = {ISENSE: Completion-Aware Crowdtesting Management},
year = {2019},
publisher = {IEEE Press},
url = {https://doi.org/10.1109/ICSE.2019.00097},
doi = {10.1109/ICSE.2019.00097},
abstract = {Crowdtesting has become an effective alternative to traditional testing, especially for mobile applications. However, crowdtesting is hard to manage in nature. Given the complexity of mobile applications and unpredictability of distributed crowdtesting processes, it is difficult to estimate (a) remaining number of bugs yet to be detected or (b) required cost to find those bugs. Experience-based decisions may result in ineffective crowdtesting processes, e.g., there is an average of 32% wasteful spending in current crowdtesting practices.This paper aims at exploring automated decision support to effectively manage crowdtesting processes. It proposes an approach named iSENSE which applies incremental sampling technique to process crowdtesting reports arriving in chronological order, organizes them into fixed-size groups as dynamic inputs, and predicts two test completion indicators in an incremental manner. The two indicators are: 1) total number of bugs predicted with Capture-ReCapture model, and 2) required test cost for achieving certain test objectives predicted with AutoRegressive Integrated Moving Average model. The evaluation of iSENSE is conducted on 46,434 reports of 218 crowdtesting tasks from one of the largest crowdtesting platforms in China. Its effectiveness is demonstrated through two application studies for automating crowdtesting management and semi-automation of task closing trade-off analysis. The results show that iSENSE can provide managers with greater awareness of testing progress to achieve cost-effectiveness gains of crowdtesting. Specifically, a median of 100% bugs can be detected with 30% saved cost based on the automated close prediction.},
booktitle = {Proceedings of the 41st International Conference on Software Engineering},
pages = {912–923},
numpages = {12},
keywords = {crowdtesting, automated close prediction, crowdtesting management, test completion},
location = {Montreal, Quebec, Canada},
series = {ICSE '19}
}

@article{10.1145/3385678.3385684,
author = {Niu, Nan},
title = {Reports from SIGSOFT CAPS Travel Awardees of ASE 2019},
year = {2020},
issue_date = {April 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {2},
issn = {0163-5948},
url = {https://doi.org/10.1145/3385678.3385684},
doi = {10.1145/3385678.3385684},
abstract = {ACM SIGSOFT, via its CAPS program, supports students and professionals to attend conferences in software engineering and related fields. This report summarizes the conference experiences from CAPS awardees of ASE 2019, and introduces a recent initiative to broaden the CAPS travel support for professionals (e.g., junior researchers and faculty members).},
journal = {SIGSOFT Softw. Eng. Notes},
month = {apr},
pages = {19},
numpages = {1}
}

@article{10.1145/3408314,
author = {Davoudian, Ali and Liu, Mengchi},
title = {Big Data Systems: A Software Engineering Perspective},
year = {2020},
issue_date = {September 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {53},
number = {5},
issn = {0360-0300},
url = {https://doi.org/10.1145/3408314},
doi = {10.1145/3408314},
abstract = {Big Data Systems (BDSs) are an emerging class of scalable software technologies whereby massive amounts of heterogeneous data are gathered from multiple sources, managed, analyzed (in batch, stream or hybrid fashion), and served to end-users and external applications. Such systems pose specific challenges in all phases of software development lifecycle and might become very complex by evolving data, technologies, and target value over time. Consequently, many organizations and enterprises have found it difficult to adopt BDSs. In this article, we provide insight into three major activities of software engineering in the context of BDSs as well as the choices made to tackle them regarding state-of-the-art research and industry efforts. These activities include the engineering of requirements, designing and constructing software to meet the specified requirements, and software/data quality assurance. We also disclose some open challenges of developing effective BDSs, which need attention from both researchers and practitioners.},
journal = {ACM Comput. Surv.},
month = {sep},
articleno = {110},
numpages = {39},
keywords = {Big Data, Big Data systems, requirements engineering, software reference architecture, quality assurance, software engineering}
}

@inproceedings{10.1145/3460120.3484759,
author = {Yong Wong, Miuyin and Landen, Matthew and Antonakakis, Manos and Blough, Douglas M. and Redmiles, Elissa M. and Ahamad, Mustaque},
title = {An Inside Look into the Practice of Malware Analysis},
year = {2021},
isbn = {9781450384544},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3460120.3484759},
doi = {10.1145/3460120.3484759},
abstract = {Malware analysis aims to understand how malicious software carries out actions necessary for a successful attack and identify the possible impacts of the attack. While there has been substantial research focused on malware analysis and it is an important tool for practitioners in industry, the overall malware analysis process used by practitioners has not been studied. As a result, an understanding of common malware analysis workflows and their goals is lacking. A better understanding of these workflows could help identify new research directions that are impactful in practice. In order to better understand malware analysis processes, we present the results of a user study with 21 professional malware analysts with diverse backgrounds who work at 18 different companies. The study focuses on answering three research questions: (1) What are the different objectives of malware analysts in practice?, (2) What comprises a typical professional malware analyst workflow, and (3) When analysts decide to conduct dynamic analysis, what factors do they consider when setting up a dynamic analysis system? Based on participant responses, we propose a taxonomy of malware analysts and identify five common analysis workflows. We also identify challenges that analysts face during the different stages of their workflow. From the results of the study, we propose two potential directions for future research, informed by challenges described by the participants. Finally, we recommend guidelines for developers of malware analysis tools to consider in order to improve the usability of such tools.},
booktitle = {Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security},
pages = {3053–3069},
numpages = {17},
keywords = {usable security, malware analysis},
location = {Virtual Event, Republic of Korea},
series = {CCS '21}
}

@inproceedings{10.1145/1027802.1027867,
author = {Krukowski, April and Reynolds, Mark},
title = {Students as Service Champions: A Success Story},
year = {2004},
isbn = {1581138695},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1027802.1027867},
doi = {10.1145/1027802.1027867},
abstract = {University helpdesk staff have a daunting job description: work all hours of the day and night, support an impossibly diverse population using an array of software and services, and keep up with an ever-changing university environment, all without getting burned out on service altogether. While many campuses have assumed that FTEs are the only answer, Northwestern University has had tremendous success with an all-student staff for over 30 years. We'll share how we've used a team of students and student managers to:&lt;ul&gt;&lt;li&gt;provide comprehensive first level support for all major software packages and services, and fulfill the role of second-level support,&lt;/li&gt;&lt;li&gt;log over 90-95% of customer contacts, allowing for collection of detailed metrics,&lt;/li&gt;&lt;li&gt;work seamlessly with full-time staff in other areas of IT; handle tricky service issues and day-to-day helpdesk operations after full timers have gone home for the day...&lt;/li&gt;&lt;/ul&gt;...all while maintaining a customer service satisfaction rating of over 90%!},
booktitle = {Proceedings of the 32nd Annual ACM SIGUCCS Conference on User Services},
pages = {284–288},
numpages = {5},
keywords = {helpdesk, management, students, support, second-level, staffing},
location = {Baltimore, MD, USA},
series = {SIGUCCS '04}
}

@inproceedings{10.1145/3341216.3342206,
author = {Shukla, Apoorv and Hudemann, Kevin Nico and Hecker, Artur and Schmid, Stefan},
title = {Runtime Verification of P4 Switches with Reinforcement Learning},
year = {2019},
isbn = {9781450368728},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3341216.3342206},
doi = {10.1145/3341216.3342206},
abstract = {We present the design and early implementation of p4rl, a system that uses reinforcement learning-guided fuzz testing to execute the verification of P4 switches automatically at runtime. p4rl system uses our novel user-friendly query language, p4q to conveniently specify the intended properties in simple conditional statements (if-else) and check the actual runtime behavior of the P4 switch against such properties. In p4rl, user-specified p4q queries with the control plane configuration, Agent, and the Reward System guide the fuzzing process to trigger runtime bugs automatically during Agent training. To illustrate the strength of p4rl, we developed and evaluated an early prototype of p4rl system that executes runtime verification of a P4 network device, e.g., L3 (Layer-3) switch. Our initial results are promising and show that p4rl automatically detects diverse bugs while outperforming the baseline approach.},
booktitle = {Proceedings of the 2019 Workshop on Network Meets AI &amp; ML},
pages = {1–7},
numpages = {7},
keywords = {Network Verification, Machine Learning, P4, Fuzzing},
location = {Beijing, China},
series = {NetAI'19}
}

@inproceedings{10.1145/3457340.3458298,
author = {Klein, Jacques},
title = {A Journey Through Android App Analysis: Solutions and Open Challenges},
year = {2021},
isbn = {9781450384032},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3457340.3458298},
doi = {10.1145/3457340.3458298},
abstract = {Users can today download a wide variety of apps ranging from simple toy games to sophisticated business-critical apps. They rely on these apps daily to perform diverse tasks, some of them related to sensitive information such as their finance or health. Ensuring high-quality, reliable, and secure apps is thus key. In the TruX research group of the interdisciplinary center for Security, Reliability, and Trust (SnT) of the University of Luxembourg, we are working for about 10 years to deliver practical techniques, tools, and other artifacts (such as repositories) making the analysis of Android apps possible. In this paper, we will briefly introduce our key contributions in both (1) Android app static analysis to detect security issues, and (2) Android Malware Detection with machine learning. We will conclude by listing several open challenges that we are currently facing towards improving the analysis and security of Android apps.},
booktitle = {Proceedings of the 2021 International Symposium on Advanced Security on Software and Systems},
pages = {1–6},
numpages = {6},
keywords = {static analysis, android security, software security, malware detection},
location = {Virtual Event, Hong Kong},
series = {ASSS '21}
}

